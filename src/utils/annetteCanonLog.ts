// üîç PART 5 ‚Äì Canon Context Logging System
import { supabase } from '@/integrations/supabase/client';

export interface AnnetteCanonLogEntry {
  id?: string;
  timestamp: Date;
  userId: string;
  clipId: string;
  canonStatus: 'canon' | 'non_canon';
  triggeredContext: Record<string, any>;
  voiceLine: string;
  contextTags: string[];
  sessionId?: string;
}

/**
 * Logs Canon/Non-Canon insights generated by Annette
 * Used for tracking context-aware responses and building Annette's memory
 */
export async function logAnnetteCanonInsight(entry: Omit<AnnetteCanonLogEntry, 'id' | 'timestamp'>): Promise<string | null> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      console.warn('No authenticated user for Canon log entry');
      return null;
    }

    const logEntry: Omit<AnnetteCanonLogEntry, 'id'> = {
      ...entry,
      timestamp: new Date(),
      userId: entry.userId || user.id
    };

    // Store in canon_echoes table for now (can be moved to dedicated table later)
    const { data, error } = await supabase
      .from('canon_echoes')
      .insert({
        user_id: logEntry.userId,
        message: logEntry.voiceLine,
        command: logEntry.clipId,
        canonical: logEntry.canonStatus === 'canon',
        canon_confidence: logEntry.canonStatus === 'canon' ? 0.9 : 0.6,
        source: 'annette_revollver',
        location: 'dashboard',
        tags: logEntry.contextTags,
        generated_by: 'context_engine',
        verified_data: logEntry.canonStatus === 'canon'
      })
      .select('id')
      .single();

    if (error) {
      console.error('Error logging Annette Canon insight:', error);
      return null;
    }

    console.log(`üìù Canon Log: ${logEntry.canonStatus.toUpperCase()} insight logged for ${logEntry.clipId}`);
    return data?.id || null;

  } catch (error) {
    console.error('Failed to log Annette Canon insight:', error);
    return null;
  }
}

/**
 * Retrieves recent Canon insights for user analysis
 */
export async function getRecentCanonInsights(userId?: string, limit: number = 10): Promise<AnnetteCanonLogEntry[]> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    const targetUserId = userId || user?.id;
    
    if (!targetUserId) {
      return [];
    }

    const { data, error } = await supabase
      .from('canon_echoes')
      .select('*')
      .eq('user_id', targetUserId)
      .eq('source', 'annette_revollver')
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching Canon insights:', error);
      return [];
    }

    return (data || []).map(item => ({
      id: item.id,
      timestamp: new Date(item.created_at),
      userId: item.user_id,
      clipId: item.command || 'unknown',
      canonStatus: item.canonical ? 'canon' : 'non_canon',
      triggeredContext: {}, // Could be expanded to store more context
      voiceLine: item.message,
      contextTags: item.tags || []
    }));

  } catch (error) {
    console.error('Failed to fetch Canon insights:', error);
    return [];
  }
}

/**
 * Gets Canon insight statistics for memory growth tracking
 */
export async function getCanonInsightStats(userId?: string): Promise<{
  totalInsights: number;
  canonInsights: number;
  nonCanonInsights: number;
  canonRatio: number;
  topContextTags: string[];
}> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    const targetUserId = userId || user?.id;
    
    if (!targetUserId) {
      return {
        totalInsights: 0,
        canonInsights: 0,
        nonCanonInsights: 0,
        canonRatio: 0,
        topContextTags: []
      };
    }

    const { data, error } = await supabase
      .from('canon_echoes')
      .select('canonical, tags')
      .eq('user_id', targetUserId)
      .eq('source', 'annette_revollver');

    if (error) {
      console.error('Error fetching Canon stats:', error);
      return {
        totalInsights: 0,
        canonInsights: 0,
        nonCanonInsights: 0,
        canonRatio: 0,
        topContextTags: []
      };
    }

    const totalInsights = data?.length || 0;
    const canonInsights = data?.filter(item => item.canonical).length || 0;
    const nonCanonInsights = totalInsights - canonInsights;
    const canonRatio = totalInsights > 0 ? canonInsights / totalInsights : 0;

    // Extract and count context tags
    const allTags = data?.flatMap(item => item.tags || []) || [];
    const tagCounts = allTags.reduce((acc, tag) => {
      acc[tag] = (acc[tag] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const topContextTags = Object.entries(tagCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([tag]) => tag);

    return {
      totalInsights,
      canonInsights,
      nonCanonInsights,
      canonRatio,
      topContextTags
    };

  } catch (error) {
    console.error('Failed to fetch Canon stats:', error);
    return {
      totalInsights: 0,
      canonInsights: 0,
      nonCanonInsights: 0,
      canonRatio: 0,
      topContextTags: []
    };
  }
}